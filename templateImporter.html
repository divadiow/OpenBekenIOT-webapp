<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>OpenBeken Configuration Generator - Parse Tuya JSON data from Cloudcutter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <!-- jQuery -->
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
  <!-- Crypto-JS for AES operations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    /* Log Output Styling */
    #log-output,
    #output-text,
    #input-text,
    #output-text-templ,
    #output-text-scr {
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 0.9rem;
    }

    #log-output {
      height: 100%;
      /* Fill available height */
      min-height: 550px;
      /* Increased height to span roughly two rows */
      overflow-y: auto;
      background-color: #ffffff;
      /* White background */
      color: #212529;
      /* Bootstrap dark gray text */
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ced4da;
      /* Match Bootstrap input border */
      white-space: pre-wrap;
      word-break: break-all;
    }

    /* Revised colors for white background */
    .log-info {
      color: #212529;
    }

    .log-success {
      color: #28a745;
      font-weight: bold;
    }

    /* Bootstrap Success Green */
    .log-warning {
      color: #856404;
    }

    /* Bootstrap Warning Dark Yellow */
    .log-error {
      color: #dc3545;
      font-weight: bold;
    }

    /* Bootstrap Danger Red */
    .log-debug {
      color: #007bff;
    }

    /* Bootstrap Primary Blue */

    /* Drag & Drop Styling */
    #input-text {
      transition: background-color 0.3s, border-color 0.3s;
    }

    #input-text.dragover {
      background-color: #e9ecef;
      border-color: #4ec9b0;
      border-width: 2px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>OpenBeken Configuration Generator - Parse Tuya JSON data from Cloudcutter</h1>
    <p>This tool can generate OpenBeken config with one click. Just input JSON data extracted from firmware, preferrably
      taken from cloudcutter profile and get your config. Usage:</p>
    <ul>
      <li>Get cloudcutter profile text or user_param_key from BK tools (advanced users)</li>
      <li>Click <a href="https://github.com/tuya-cloudcutter/tuya-cloudcutter.github.io/tree/master/devices">here</a>
        for profiles</li>
      <li>Paste the JSON into input field</li>
      <li>When doing it in OpenBeken Web Application, you will have 'Apply template' button, just click it</li>
    </ul>
    <div class="row">
      <!-- Left Column: Inputs and Outputs -->
      <div class="col-md-8">
        <div class="row">
          <div class="col-md-6">
            <label for="input-text">Input (JSON or Drag .bin):</label>
            <textarea class="form-control" id="input-text" rows="10"
              placeholder="Paste JSON here or drag & drop Tuya firmware .bin file"></textarea>
          </div>
          <div class="col-md-6">
            <label for="output-text">Text interpretation:</label>
            <textarea class="form-control" id="output-text" rows="10"></textarea>
          </div>
        </div>
        <div class="row mt-3">
          <div class="col-md-6">
            <label for="output-text-templ">OpenBeken template:</label>
            <textarea class="form-control" id="output-text-templ" rows="10"></textarea>
          </div>
          <div class="col-md-6">
            <label for="output-text-scr">OpenBeken one shot script:</label>
            <textarea class="form-control" id="output-text-scr" rows="10"></textarea>
          </div>
        </div>
      </div>

      <!-- Right Column: Log -->
      <div class="col-md-4">
        <label for="log-output">Log:</label>
        <div id="log-output"></div>
      </div>
    </div>
    <div class="row">
      <span class="text-center">Examples (each button will fetch a cloudcutter JSON):</span>
      <div class="col-md-12 text-center">
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/athom-garage-door-opener.json')">Garage
          Door</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/aldi-casalux-wifi-led-rgb-light-strip.json')">RGB
          strip</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/lenovo-se-242dc-rgbct-bulb-v1.2.21.json')">RGBCW
          LED</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/deta-6014ha-switch.json')">Deta
          Plug</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/pegant-pg3451-3-outlet-power-strip.json')">Triple
          socket + USB</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/b04e860fe0bb1c8bed417ab36c57e6759ec08510/devices/spectrum-woj14415-rgbct-gu10-bulb.json')">SM2135
          LED</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/43a341ef1dd8eec8514e1d435563bd9008ff2835/devices/hombli-hbss-0209-smart-socket-b2030248-energy-plug.json')">BL0937
          PLUG</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/b04e860fe0bb1c8bed417ab36c57e6759ec08510/devices/tuya-generic-rr620w-jl-smart-switch.json')">BL0942
          power metering plug</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/nous-p4-e14-rgbct-bulb.json')">BP5758
          LED</button>
        <button class="btn btn-primary mt-3" id="parse-btn"
          onclick="loadSample('https://raw.githubusercontent.com/tuya-cloudcutter/tuya-cloudcutter.github.io/a8a6539aad21a03d5db41e4d27e9d5516c62fe23/devices/lsc-3004200-wifi-outdoor-dual-socket.json')">Bridge
          socket (TODO)</button>
      </div>


    </div>
  </div>
  <script type="text/javascript" src="templateParser.js"></script>
  <script>
    var inputText;
    var outputText_desc;
    var outputText_script;
    var outputText_template;
    var logOutput;

    function loadSample(url) {
      fetch(url)
        .then(function (response) {
          return response.json();
        })
        .then(function (data) {
          inputText.value = JSON.stringify(data, null, 2);
          refreshFields();
        })
        .catch(function (error) {
          log('Error fetching JSON: ' + error, 'error');
          console.error('Error fetching JSON: ', error);
        });

    }
    function refreshFields() {
      log("Starting text parsing...", 'info');
      try {
        let res = processJSON(inputText.value);
        if (!res) {
          throw new Error("processJSON returned null/undefined");
        }
        log("JSON structure valid. Processing...", 'info');

        outputText_desc.value = res.desc;
        outputText_script.value = res.scr;
        outputText_template.value = JSON.stringify(res.tmpl, null, 2);

        // Try to extract some info for log
        let info = [];
        if (res.tmpl.vendor) info.push(res.tmpl.vendor);
        if (res.tmpl.model) info.push(res.tmpl.model);
        if (info.length > 0) {
          log(`Parsed device: ${info.join(" ")}`, 'success');
        } else {
          log("Parsed successfully.", 'success');
        }
      } catch (e) {
        log("Error parsing JSON: " + e.message, 'error');
        // Optional: clear outputs on error? Or keep previous?
        // Keeping previous might be better for user correction.
      }
    }

    // --- Logging Utils ---
    function log(msg, type = 'info') {
      const div = document.createElement('div');
      div.className = `log-${type}`;
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      if (logOutput) {
        logOutput.appendChild(div);
        logOutput.scrollTop = logOutput.scrollHeight;
      }
      console.log(`[${type}] ${msg}`);
    }

    // --- Tuya KV Storage Logic ---

    // Constants
    const SECTOR_SIZE = 4096;
    const PAGE_SIZE = 128;
    const MAGIC_PROTECTED = 0x13579753;
    const MAGIC_KEY = 0x13579753;
    const MAGIC_DATA_1 = 0x98761234;
    const MAGIC_DATA_2 = 0x135726AB;

    // Keys
    const KEY_MASTER = "qwertyuiopasdfgh";
    const KEY_PART_1 = "8710_2M";
    const KEY_PART_2 = "HHRRQbyemofrtytf";
    const MAGIC_CONFIG_START = [0x46, 0xDC, 0xED, 0x0E, 0x67, 0x2F, 0x3B, 0x70, 0xAE, 0x12, 0x76, 0xA3, 0xF8, 0x71, 0x2E, 0x03];

    // Utils
    function readUInt32LE(buffer, offset) {
      return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
    }
    function readUInt16LE(buffer, offset) {
      return (buffer[offset] | (buffer[offset + 1] << 8));
    }
    function readUInt8(buffer, offset) {
      return buffer[offset];
    }

    function checkCRC(expected, data, offset, len) {
      let n = 0n;
      for (let i = 0; i < len; i++) {
        n += BigInt(data[offset + i]);
      }
      const val = Number(n & 0xFFFFFFFFn);
      return val === expected;
    }

    // Crypto
    function makeSecondaryKey(innerKey) {
      const keyPart1Bytes = new TextEncoder().encode(KEY_PART_1);
      const keyPart2Bytes = new TextEncoder().encode(KEY_PART_2);
      const key = new Uint8Array(16);
      for (let i = 0; i < 16; i++) {
        key[i] = (keyPart1Bytes[i & 3] + keyPart2Bytes[i]) & 0xFF;
      }
      for (let i = 0; i < 16; i++) {
        key[i] = (key[i] + innerKey[i]) % 256;
      }
      return key;
    }

    function decryptBlock(data, baseOffset, blockIndex, keyBytes) {
      const readOfs = baseOffset + SECTOR_SIZE * blockIndex;
      if (readOfs + SECTOR_SIZE > data.length) return null;

      const blockData = data.slice(readOfs, readOfs + SECTOR_SIZE);
      const keyWordArr = CryptoJS.lib.WordArray.create(keyBytes);
      const dataWordArr = CryptoJS.lib.WordArray.create(blockData);

      const decryptedWords = CryptoJS.AES.decrypt(
        { ciphertext: dataWordArr },
        keyWordArr,
        { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.ZeroPadding }
      );

      const sigBytes = decryptedWords.sigBytes;
      const words = decryptedWords.words;
      const result = new Uint8Array(sigBytes);
      // WordArray to Uint8Array loop
      for (let i = 0; i < sigBytes; i++) {
        result[i] = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
      }
      if (result.length < SECTOR_SIZE) {
        const padded = new Uint8Array(SECTOR_SIZE);
        padded.set(result);
        return padded;
      }
      return result;
    }

    function findMagic(data) {
      for (let i = 0; i < data.length - MAGIC_CONFIG_START.length; i++) {
        let found = true;
        for (let j = 0; j < MAGIC_CONFIG_START.length; j++) {
          if (data[i + j] !== MAGIC_CONFIG_START[j]) { found = false; break; }
        }
        if (found) return i;
      }
      return -1;
    }

    // --- Parser Classes ---

    class DataBlock {
      constructor(id, data, mapData) {
        this.id = id;
        this.data = data; // Full 4096 bytes
        this.mapData = mapData; // Bitmap for page types
        this.pages = {}; // cache
      }

      isIndexPage(pageIndex) {
        // pageIndex 1..31 (0 is header)
        // Bitmap logic: map_data[i // 8] & (1 << i % 8)
        const byteIdx = Math.floor(pageIndex / 8);
        const bitIdx = pageIndex % 8;
        if (byteIdx >= this.mapData.length) return false;
        return (this.mapData[byteIdx] & (1 << bitIdx)) !== 0;
      }

      getPage(pageIndex) {
        const start = pageIndex * PAGE_SIZE;
        return this.data.slice(start, start + PAGE_SIZE);
      }
    }

    function decodeTuyaConfig(data) {
      logOutput.textContent = '';
      log("Starting Tuya Config Decryption (KV Storage Mode)...", 'info');

      let needle = findMagic(data);
      if (needle < 0) {
        log("Magic header not found!", 'error');
        return;
      }

      const realStart = needle - 32;
      log(`Magic found at ${needle}. Config starts at ${realStart}.`, 'success');

      if (realStart < 0) { log("Invalid start position.", 'error'); return; }

      // 1. Decrypt Block 0 (Key Block)
      const masterKeyBytes = new TextEncoder().encode(KEY_MASTER);
      const block0 = decryptBlock(data, realStart, 0, masterKeyBytes);

      if (!block0) { log("Failed to decrypt Block 0.", 'error'); return; }

      // Verify Block 0
      const mag = readUInt32LE(block0, 0);
      if (mag !== MAGIC_KEY) {
        log(`Block 0 Magic mismatch: 0x${mag.toString(16)} (Expected 0x${MAGIC_KEY.toString(16)})`, 'error');
        return;
      }

      const innerKey = block0.slice(8, 24);
      const secondaryKey = makeSecondaryKey(innerKey);
      log("Secondary key derived.", 'success');

      // 2. Decrypt and Parse All Blocks
      const blocks = new Map(); // Id -> DataBlock

      for (let i = 1; i < 500; i++) {
        const decrypted = decryptBlock(data, realStart, i, secondaryKey);
        if (!decrypted) break;

        // Parse Header (Page 0)
        const blkMag = readUInt32LE(decrypted, 0);

        if (blkMag !== MAGIC_DATA_1 && blkMag !== MAGIC_DATA_2) {
          continue;
        }

        const blkId = readUInt16LE(decrypted, 8); // Offset 8
        const mapSize = readUInt8(decrypted, 14); // Offset 14
        const mapData = decrypted.slice(15, 15 + mapSize);

        const blockObj = new DataBlock(blkId, decrypted, mapData);
        blocks.set(blkId, blockObj);
      }

      log(`Decrypted and parsed ${blocks.size} data blocks.`, 'success');

      // 3. Scan for Index Pages and Reassemble Files
      const files = new Map(); // Filename -> Uint8Array content

      blocks.forEach((blk, blkId) => {
        for (let p = 1; p < 32; p++) {
          if (blk.isIndexPage(p)) {
            // Parse Index Page
            const pageData = blk.getPage(p);

            const itemLen = readUInt32LE(pageData, 4);
            const nameLen = readUInt8(pageData, 17); // Check offset: 4+4+2+1+2+4 = 17?

            if (nameLen === 0 || nameLen > 100) continue; // Sanity check

            const nameBytes = pageData.slice(18, 18 + nameLen - 1);
            const name = new TextDecoder().decode(nameBytes).replace(/\0/g, '');

            // Parse Parts
            let partsOffset = 18 + nameLen;
            const partsSize = readUInt16LE(pageData, 11);

            let fileData = new Uint8Array(itemLen);
            let written = 0;

            for (let k = 0; k < partsSize; k++) {
              if (partsOffset + 4 > PAGE_SIZE) break;

              const pBlockId = readUInt16LE(pageData, partsOffset);
              const pStart = readUInt8(pageData, partsOffset + 2);
              const pEnd = readUInt8(pageData, partsOffset + 3);
              partsOffset += 4;

              const partBlock = blocks.get(pBlockId);
              if (!partBlock) {
                log(`Missing block ${pBlockId} for file ${name}`, 'warning');
                continue;
              }

              for (let pg = pStart; pg <= pEnd; pg++) {
                // Data Page
                const chunk = partBlock.getPage(pg);
                const toWrite = Math.min(PAGE_SIZE, itemLen - written);
                fileData.set(chunk.slice(0, toWrite), written);
                written += toWrite;
                if (written >= itemLen) break;
              }
            }

            files.set(name, fileData);
          }
        }
      });

      // 4. Extract content
      log(`Recovered ${files.size} files: ${Array.from(files.keys()).join(', ')}`, 'success');

      if (files.has("user_param_key")) {
        const upk = new TextDecoder().decode(files.get("user_param_key"));
        parseAndSet(upk, "user_param_key");
      } else {
        log("user_param_key not found in KV storage.", 'warning');
        // Maybe dump everything?
        if (files.size > 0) {
          log("Dumping available file names to log...", 'info');
          files.forEach((v, k) => log(`File: ${k} (${v.length} bytes)`, 'info'));
        }
      }
    }

    function parseAndSet(jsonStr, source) {
      // 1. Initial cleanup: remove nulls
      let clean = jsonStr.replace(/\0/g, '');

      // 2. Trim to outer braces
      const firstBrace = clean.indexOf('{');
      const lastBrace = clean.lastIndexOf('}');
      if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        clean = clean.substring(firstBrace, lastBrace + 1);
      }

      // 3. Attempt parse loop
      try {
        const parsed = JSON.parse(clean);
        inputText.value = JSON.stringify(parsed, null, 2);
        log(`Successfully loaded ${source}`, 'success');
        refreshFields();
        return;
      } catch (e) {
        log(`Standard parse failed for ${source}: ${e.message}`, 'warning');
      }

      // 4. Heuristic Repairs
      // Tuya C-SDK output often has:
      // - Unquoted keys: {key:val}
      // - Unquoted string values: {key:CB3S}
      // - Trailing commas: {key:val,}
      log("Attempting heuristic repair...", 'info');

      let repaired = clean;

      // Remove non-printable but keep newlines/tabs
      repaired = repaired.replace(/[^\x20-\x7E\n\r\t]/g, '');

      // Fix trailing commas: ,} -> } and ,] -> ]
      repaired = repaired.replace(/,\s*}/g, '}');
      repaired = repaired.replace(/,\s*]/g, ']');

      // Quote unquoted keys:  {key:  or ,key:
      repaired = repaired.replace(/([\{,]\s*)([a-zA-Z0-9_]+)\s*:/g, '$1"$2":');

      // Quote unquoted values (alphanumeric/dot/underscore)
      // This will quote numbers too ("1", "0") but that's safe for simple config parsers
      // Captures :value follwed by , or }
      repaired = repaired.replace(/:\s*([a-zA-Z0-9_\.]+)\s*([,}])/g, ':"$1"$2');

      // Attempt parse again
      try {
        const parsed = JSON.parse(repaired);
        inputText.value = JSON.stringify(parsed, null, 2);
        log(`Successfully loaded ${source} after repair`, 'success');
        refreshFields();
        return;
      } catch (e) {
        log(`Repair parse failed: ${e.message}`, 'warning');
        // log(`Repaired content was: ${repaired}`, 'debug'); 
      }

      // 5. Fallback: formatted raw dump
      log("Dumping raw repaired content.", 'warning');

      let formatted = repaired;
      if (formatted.length > 0 && !formatted.includes('\n')) {
        formatted = formatted.replace(/,/g, ',\n');
        formatted = formatted.replace(/{/g, '{\n');
        formatted = formatted.replace(/}/g, '\n}');
      }

      inputText.value = formatted;
      refreshFields(); // Try anyway
    }

    document.addEventListener('DOMContentLoaded', function () {
      inputText = document.getElementById('input-text');
      outputText_desc = document.getElementById('output-text');
      outputText_script = document.getElementById('output-text-scr');
      outputText_template = document.getElementById('output-text-templ');
      logOutput = document.getElementById('log-output');

      inputText.addEventListener('change', function () {
        refreshFields();
      });

      // --- Drag & Drop Initialization ---
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        inputText.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      inputText.addEventListener('dragover', () => inputText.classList.add('dragover'));
      ['dragleave', 'drop'].forEach(evt => {
        inputText.addEventListener(evt, () => inputText.classList.remove('dragover'));
      });

      inputText.addEventListener('drop', handleDrop);

      function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        if (files && files.length > 0) {
          const file = files[0];
          if (file.name.toLowerCase().endsWith('.bin')) {
            log(`Processing dropped file: ${file.name}`, 'info');
            const reader = new FileReader();
            reader.onload = (evt) => {
              const arrayBuffer = evt.target.result;
              const uint8Array = new Uint8Array(arrayBuffer);
              try {
                decodeTuyaConfig(uint8Array);
              } catch (err) {
                log(`Decryption crash: ${err.message}`, 'error');
                console.error(err);
              }
            };
            reader.readAsArrayBuffer(file);
          } else {
            log(`Dropped file is not .bin, trying text read for ${file.name}`, 'warning');
            const reader = new FileReader();
            reader.onload = (evt) => {
              inputText.value = evt.target.result;
              refreshFields();
              log("Loaded text file content.", 'success');
            };
            reader.readAsText(file);
          }
        }
      }
    });
  </script>
</body>

</html>